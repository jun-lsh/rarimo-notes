# The Passport Spec

Rarimo relies on passports adhering to the ICAO MachineÂ Readable Travel Documents standard, with each passport containing a Machine-Readable Zone (MRZ):

![](passport_MRZ.png)

The MRZ has an RFID chip which contains a set of Data Groups (DG) as follows:

![](passport_memory_DGs.jpg)

Of note is DG15, the _Active Authentication Public Key_. The passport chip contains a private key that cannot be read or copied but can be used to sign challenges sent to the passport, which in turn can be checked against this public key as an anti-cloning measure. *Do note that the existence of this public key on its own is **not** the anti-cloning measure*.

Furthermore, the chip contains a file known as a Document Security Object (DSO), where hash values of all the other DGs and a digital signature of the hashes are stored. The DSO can then be checked against a Document Signer Certificate (DSC), which may reside on the chip or has to be retrieved from the Issuing Authority, then the DSC has to be checked against the Country Signing Certificate Authority (CSCA) (to be retrieved from the issuing authority) and then checked against the Certificate Revocation List (CRL) to check for continued validity. Wow!

![](PKDChain.jpg)

This is the chain of trust which we rely on to ensure that the contents of the passport are valid.

Using Basic Access Control (BAC), an encrypted version of the passport data can be pulled from the RFID chip, then decoded using data derived from the MRZ itself.  

By virtue of relying on biometric passports, this means that Rarimo isn't applicable for citizens of:
- Vietnam
- Egypt
- India
- Pakistan
- El Salvador
- Most of Africa, actually
- South Africa
- A good chunk of the Middle East
- _People who can't afford to get a passport_

We'll highlight whatever issues we spot along the way as we look through the technical implementation.

# Deriving The Profile

We'll go through it step-by-step as described in the docs:
1. User generates a keypair `<sk, pk>` 
2. User signs `pk` via passport active authentication by using `pk` as a challenge, generating `sig = sign(Hash(pk)[:64], sk_pass)`
	1. If you _do_ do this, the biggest issue with it (and part of the whole premise this protocol is built upon anyways) is that _this challenge signing requires zero further authentication whatsoever_. There is no checking of biometrics against the passport data or whatnot, _if you have **anybody's** passport, you can generate this signature_. Quite obviously the biggest pitfall is that if you steal someone's passport/have your passport stolen, _then too bad_. 
	2. Also, not all passports have active authentication! In this scenario, it's at least [implied in the README here](https://github.com/rarimo/passport-zk-circuits/) that they will instead use a Poseidon hash of the SHA256 hash of a subset of the signed attributes. In theory, I could clone a passport and just have active authentication disabled and force the fallback, essentially bypassing this measure. The [docs](https://docs.rarimo.com/accounts/zk-passport/#challenges-and-limitations) however juts say that those passports would be unsupported.
3. A ZKP `reg_proof` is generated that proves the passport public key belongs to the passport
	1. The docs say this proof shows that the passport public key "is signed by a key from the ICAO list, without revealing the exact passport's issuer". But the passport public key isn't signed by them? I'm assuming it's the signed version of the hash of the public key found in the DSO they're talking about.
4. The circuit calculates a commitment `DG_commit = Hash(DG1 || Hash(sk))`
5. The user submits `<pk, passport public key, sig, reg_proof>` to the smart contract.